<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <meta charset="utf-8"/> <title>Plump</title> <meta name="viewport" content="width=device-width"/> <meta name="description" content="An XML / XHTML / HTML parser that aims to be as lenient as possible."/> <meta name="author" content="Nicolas Hafner &lt;shinmera@tymoon.eu&gt;"/> <style type="text/css"> body{
          max-width: 1024px;
          margin: 0 auto 0 auto;
          font-family: sans-serif;
          color: #333333;
          font-size: 14pt;
          padding: 5px;
      }
      body>header{
          display:flex;
          align-items: center;
          justify-content: center;
          flex-direction: column;
          max-width: 100%;
          text-align: center;
      }
      body>header img{
          max-width: 50%;
      }
      img{
          max-width: 100%;
          max-height: 100%;
      }
      code{
          font-family: Consolas, Inconsolata, monospace;
      }
      a{
          text-decoration: none;
          color: #0055AA;
      }
      a img{
          border: none;
      }
      #documentation{
          text-align: justify;
      }
      #documentation pre{
          margin-left: 20px;
          overflow: auto;
      }
      #documentation img{
          margin: 5px;
      }
      #symbol-index>ul{
          list-style: none;
          padding: 0;
      }
      #symbol-index .package>ul{
          list-style: none;
          padding: 0 0 0 10px;
      }
      #symbol-index .package .nicknames{
          font-weight: normal;
      }
      #symbol-index .package h4{
          display: inline-block;
          margin: 0;
      }
      #symbol-index .package article{
          margin: 0 0 15px 0;
      }
      #symbol-index .package article header{
          font-size: 1.2em;
          font-weight: normal;
      }
      #symbol-index .package .name{
          margin-right: 5px;
      }
      #symbol-index .package .docstring{
          margin: 0 0 0 15px;
          white-space: pre-wrap;
          font-size: 12pt;
      }
      @media (max-width: 800px){
          body{font-size: 12pt;}
      } </style> </head> <body> <header> <h1><img alt="plump" src="plump-logo.png"/></h1> <span class="version">1.0.0</span> <p class="description">An XML / XHTML / HTML parser that aims to be as lenient as possible.</p> </header> <main> <article id="documentation">  <div><h2>What is Plump?</h2> <p>Plump is a parser for HTML/XML like documents, focusing on being lenient towards invalid markup. It can handle things like invalid attributes, bad closing tag order, unencoded entities, inexistent tag types, self-closing tags and so on. It parses documents to a class representation and offers a small set of DOM functions to manipulate it. You are free to change it to parse to your own classes though.</p> <h2>How To</h2> <p>Load Plump through Quicklisp or ASDF:</p> <pre><code>(ql:quickload :plump)
</code></pre> <p>Using the <code>PARSE</code> function, plump will transform a string, pathname or stream into a document:</p> <pre><code>(plump:parse &quot;&lt;foo&gt;&lt;bar this is=\&quot;a thing\&quot;&gt;baz&lt;/bar&gt;&lt;span id=\&quot;test\&quot;&gt;oh my&quot;)
</code></pre> <p>This returns a root node. If you want to append a document to a root node (or any other node that accepts children) that you've made, you can pass it into the parse function. To return the document into a readable form, you can call <code>SERIALIZE</code>:</p> <pre><code>(plump:serialize *)
</code></pre> <p>Using the DOM you can easily traverse the document and change it:</p> <pre><code>(plump:remove-child (plump:get-element-by-id ** &quot;test&quot;))
(plump:serialize ***)
</code></pre> <p>By default plump includes a few special tag dispatchers to catch HTML oddities like self-closing tags and fulltext-nodes. Especially the self-closing tags can lead to problems in XML documents. In order to parse without any HTML &quot;tricks&quot;, you can simply do:</p> <pre><code>(<a href="http://l1sp.org/cl/let">let</a> ((plump:*tag-dispatchers* plump:*xml-tags*)) (plump:parse &quot;&lt;link&gt;foo&lt;/link&gt;&quot;))
</code></pre> <h2>Extending Plump</h2> <p>If you want to handle a certain tag in a special way, you can write your own tag-dispatcher. For example comments, the doctype and self-closing tags are handled in this fashion. In order to properly hook in, you will have to learn to use Plump's lexer (see next section).</p> <pre><code>(plump:define-tag-dispatcher (my-dispatcher *tag-dispatchers*) (name)
    (<a href="http://l1sp.org/cl/string-equal">string-equal</a> name &quot;my-tag&quot;)
  (<a href="http://l1sp.org/cl/let">let</a> ((attrs (plump:read-attributes)))
    (<a href="http://l1sp.org/cl/when">when</a> (<a href="http://l1sp.org/cl/char=">char=</a> (plump:consume) #\/)
      (plump:consume)) ;; Consume closing
    (<a href="http://l1sp.org/cl/make-instance">make-instance</a> 'my-tag :parent plump:*root* :attributes attrs)))
</code></pre> <p>If you don't want to disturb the standard Plump tag dispatchers list, you can define your own special variable to contain the dispatchers and bind <code>*tag-dispatchers*</code> to that during parsing, as shown for the XML example above. Shorthand macros exist to define self-closing or full-text tags:</p> <pre><code>(plump:define-self-closing-element img *tag-dispatchers* *html-tags*)
(plump:define-fulltext-element style *tag-dispatchers* *html-tags*)
</code></pre> <p>XML allows for script tags (like <code>&lt;?php ?&gt;</code>). By default Plump does not specify any special reading for any script tag. If an unhandled script tag is encountered, a warning is emitted and Plump will try to just read anything until <code>?&gt;</code> is encountered. For most script tags this probably will not suffice, as they might contain some form of escaped <code>?&gt;</code>. If you do want to use Plump to process script tags properly as well, you will have to define your own reader with <code>define-processing-parser</code>. You can also use that macro to define a reader that outputs a more suitable format than a text tag.</p> <p>During parsing, all elements are created through <code>MAKE-*</code> functions like <code>MAKE-ROOT</code>, <code>MAKE-ELEMENT</code>, <code>MAKE-TEXT-NODE</code>, and so on. By overriding these functions you can instead delegate the parsing to your own DOM.</p> <p>If you subclass the DOM classes, you might want to define a method on <code>SERIALIZE-OBJECT</code> to produce the right output.</p> <h2>Plump's Lexer</h2> <p>Since parser generators are good for strict grammars and Plump needed to be fast and lenient, it comes with its own primitive reading/lexing mechanisms. All the lexer primitives are defined in <code>lexer.lisp</code> and you can leverage them for your own projects as well, if you so desire.</p> <p>In order to allow the lexing to work, you'll have to wrap your processing code in <code>with-lexer-environment</code>. You can then use functions like <code>consume</code>, <code>advance</code>, <code>unread</code>, <code>peek</code> and <code>consume-until</code> to process the input.</p> <p><code>make-matcher</code> allows you to use a very simple language to define matching operations. This will evaluate to a function with no arguments that should return <code>T</code> if it matches and <code>NIL</code> otherwise. Combining matchers with <code>consume-until</code> allows you to easily make sequence readers:</p> <pre><code>(plump:with-lexer-environment (&quot;&lt;foo&gt;&quot;)
  (<a href="http://l1sp.org/cl/when">when</a> (<a href="http://l1sp.org/cl/char=">char=</a> #\&lt; (plump:consume))
    (plump:consume-until (plump:make-matcher (is #\&gt;)))))
</code></pre> <p>Available matcher constructs are <code><a href="http://l1sp.org/cl/not">not</a></code>, <code><a href="http://l1sp.org/cl/and">and</a></code>, <code><a href="http://l1sp.org/cl/or">or</a></code>, <code>is</code>, <code>in</code>, <code>next</code>, <code>prev</code>, <code>any</code>, and <code><a href="http://l1sp.org/cl/find">find</a></code>. <code>define-matcher</code> allows you to associate keywords to matchers, which you can then use as a matcher rule in <code>make-matcher</code>. Regular symbols act as variables:</p> <pre><code>(<a href="http://l1sp.org/cl/let">let</a> ((find &quot;baz&quot;))
  (plump:with-lexer-environment (&quot;foo bar baz&quot;)
     (plump:consume-until (plump:make-matcher (is find)))))
</code></pre> <h2>Speed</h2> <p><img src="http://shinmera.tymoon.eu/public/plump-benchmark.png" alt="benchmark"/></p> <p>If you know of other native-lisp libraries that beat Plump, please do let me know, I would be very interested!</p> <h2>See Also</h2> <ul> <li><a href="https://shinmera.github.io/lquery/">lQuery</a> Dissect and manipulate the DOM with jQuery-like commands.</li> <li><a href="https://shinmera.github.io/CLSS/">CLSS</a> Traverse the DOM by CSS selectors.</li> <li><a href="https://github.com/Shinmera/plump-tex">plump-tex</a> Serialize between TeX and the Plump DOM.</li> <li><a href="https://github.com/Shinmera/plump-sexp">plump-sexp</a> Serialize between SEXPrs and the Plump DOM.</li> </ul> </div>  </article> <article id="copyright">  <h2>Copyright</h2> <span>plump</span> is licensed under the <span><a href="https://tldrlegal.com/search?q=Artistic">Artistic</a></span> license.  Â© <span>Nicolas Hafner &lt;shinmera@tymoon.eu&gt;</span> .  This library can be obtained on <a href="https://github.com/Shinmera/plump">https://github.com/Shinmera/plump</a>.  </article>  </main> </body> </html> 